Here is an example of using command line arguments in a Bash script:

```bash
#!/bin/bash

echo "Script Name: $0"
echo "First Argument: $1"
echo "Second Argument: $2"
echo "All Arguments with \$*: $*"
echo "All Arguments with \$@: $@"
echo "Total Number of Arguments: $#"
```

If you save this script as `command_line.sh` and run it with arguments like this:

```bash
bash command_line.sh arg1 arg2 arg3
```

The output will be:

```
Script Name: command_line.sh
First Argument: arg1
Second Argument: arg2
All Arguments with $*: arg1 arg2 arg3
All Arguments with $@: arg1 arg2 arg3
Total Number of Arguments: 3
```

- `$0` is the script name.
- `$1`, `$2`, ... are the positional parameters for the arguments passed.
- `$*` and `$@` hold all the arguments.
- `$#` shows the total count of arguments.

This is a basic usage example of command line arguments in bash scripts.[1][2][4]

[1](https://www.windmill.dev/blog/bash-scripts-arguments)
[2](https://codedamn.com/news/linux/how-to-use-command-line-arguments-in-bash-scripts)
[3](https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash)
[4](https://notes.kodekloud.com/docs/Advanced-Bash-Scripting/Refresher/Command-Line-Arguments)
[5](https://phoenixnap.com/kb/bash-read) [6](https://www.youtube.com/watch?v=Xe0BbRu06Jw)
[7](https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script)
[8](https://how-to.fandom.com/wiki/How_to_read_command_line_arguments_in_a_bash_script)
[9](https://www.redhat.com/en/blog/arguments-options-bash-scripts) [10](https://refine.dev/blog/bash-script-arguments/)

In Bash, the difference between $\* and $@ is primarily in how they handle command-line arguments, especially when quoted.

### Summary

- **$\*** treats all arguments as a single string, with arguments separated by the first character of the `IFS` variable (by
  default, a space).
- **$@** treats each argument as a separate entity, preserving the original argument boundaries.

### Detailed Explanation

- When **unquoted**, both $\* and $@ expand to all positional arguments separated by spaces, which generally behaves the
  same.
- When **quoted**, the difference becomes significant:
  - **"$\*"** combines all arguments into a single string, separated by the first `IFS` character, usually resulting in one
    string containing all arguments joined together.
  - **"$@"** expands each argument into a separate quoted string, preserving the original argument boundaries, which is
    especially useful when handling arguments with spaces.[1][3][4]

### Practical Usage

- Use **"$@"** when you need to iterate over each argument individually, such as in loops or passing arguments to other
  commands, because it preserves the arguments' structure.
- Use **"$\*"** if you want to treat all arguments as a single string, often suitable for string concatenation or passing to
  commands expecting one input.

### Summary Table

| Variant            | Quoted Behavior                                          | Usage Scenario                                           |
| ------------------ | -------------------------------------------------------- | -------------------------------------------------------- |
| **$\* (unquoted)** | Expands to all arguments separated by spaces             | Simple concatenation of all args                         |
| **"$\*"**          | Single string with all arguments joined by IFS character | When all arguments should be combined as a single string |
| **$@ (unquoted)**  | Expands to all arguments separated by spaces             | Looping or passing arguments as-is                       |
| **"$@"**           | Expands to each argument as a separate quoted string     | Preserves original argument structure, ideal for loops   |

**In most scripting scenarios, especially when handling arguments with spaces, it is recommended to use **"$@"** for safety
and correctness.**

[1](https://www.baeldung.com/linux/dollar-star-at) [2](https://www.youtube.com/watch?v=qZcT4VfF5lM)
[3](https://stackoverflow.com/questions/2761723/what-is-the-difference-between-and-in-shell-scripts)
[4](https://www.reddit.com/r/bash/comments/ezpom1/vs/)

The IFS (Internal Field Separator) variable in Bash is a special shell variable that defines the characters used to separate
text into tokens or fields when the shell processes words from a string. By default, IFS includes whitespace characters:
space, tab, and newline. These characters tell Bash where to split a string into words during expansions and input
processing.

Specifically, when Bash interprets a string (like command-line arguments or output from command substitutions), it splits the
string into separate words using the characters set in IFS as delimiters. If IFS remains unset or is set to its default
("space, tab, newline"), sequences of these whitespace characters at the beginning and end of the string are ignored, and
they act as delimiters inside the string. If IFS is set to other characters, these characters (and adjacent whitespace
characters) serve as delimiters, changing how the string is split.

This variable is important for tasks like parsing input, reading files line-by-line, and splitting arguments correctly. Users
can modify IFS to customize how splitting happens, for example, using a colon (:) to parse colon-separated values, but it's
common to reset it to default or to save and restore original values in scripts for safety.[1][2][3]

[1](https://en.wikipedia.org/wiki/Input_Field_Separators)
[2](https://delightlylinux.wordpress.com/2020/02/16/bash-ifs-what-is-the-internal-field-separator/)
[3](https://tldp.org/LDP/abs/html/internalvariables.html)
[4](https://stackoverflow.com/questions/74072715/how-to-use-internal-field-separator-correctly)
[5](https://www.baeldung.com/linux/ifs-shell-variable)
[6](https://gist.github.com/magnetikonline/5172b4dafcdc079f28e60f512528c8a6)
